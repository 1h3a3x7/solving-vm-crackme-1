unsigned char g_vm_bytecode[ 518 ] =
{
    // 0xDEADC0DE = first 4 bytes
    0xDE, 0xAD, 0xC0, 0xDE, 
    // Code
    0x7C, 0x2E, 0x27, 0x25, 0x2D, 0x39, 0x32, 0x2E, 0x23, 0x39, 0x36, 0x2A,
    0x27, 0x28, 0x23, 0x32, 0x70, 0x00, 0x00, 0x00, 0x2F, 0x75, 0x05, 0x71, 0x30, 0x73, 0x00, 0x6D,
    0x22, 0x76, 0x02, 0x79, 0x33, 0x7A, 0x70, 0x00, 0x00, 0x00, 0x46, 0x71, 0x10, 0x76, 0x01, 0x78,
    0x27, 0x70, 0x00, 0x00, 0x00, 0x30, 0x71, 0x10, 0x76, 0x01, 0x77, 0x16, 0x70, 0x00, 0x00, 0x00,
    0x39, 0x71, 0x10, 0x76, 0x01, 0x77, 0x0B, 0x70, 0x00, 0x00, 0x00, 0x41, 0x71, 0x01, 0x76, 0x01,
    0x77, 0x06, 0x6D, 0x00, 0x76, 0x00, 0x79, 0x05, 0x6D, 0x00, 0x6B, 0x00, 0x66, 0x75, 0x40, 0x70,
    0x00, 0x00, 0x00, 0x07, 0x71, 0x30, 0x6D, 0x11, 0x7B, 0x73, 0x00, 0x70, 0x00, 0x00, 0x00, 0x30,
    0x71, 0x20, 0x68, 0x02, 0x70, 0x00, 0x00, 0x00, 0x0A, 0x71, 0x20, 0x76, 0x02, 0x77, 0x09, 0x70,
    0x00, 0x00, 0x00, 0x07, 0x71, 0x20, 0x68, 0x02, 0x70, 0x00, 0x00, 0x00, 0x10, 0x71, 0x20, 0x69,
    0x12, 0x67, 0x10, 0x75, 0x2B, 0x70, 0xF3, 0x37, 0x46, 0xE6, 0x71, 0x20, 0x76, 0x12, 0x6D, 0x00,
    0x79, 0x03, 0x6B, 0x00, 0x66, 0x70, 0x00, 0x00, 0x00, 0x07, 0x71, 0x30, 0x6D, 0x11, 0x7B, 0x73,
    0x00, 0x70, 0x00, 0x00, 0x00, 0x30, 0x71, 0x20, 0x68, 0x02, 0x70, 0x00, 0x00, 0x00, 0x0A, 0x71,
    0x20, 0x76, 0x02, 0x77, 0x09, 0x70, 0x00, 0x00, 0x00, 0x07, 0x71, 0x20, 0x68, 0x02, 0x70, 0x00,
    0x00, 0x00, 0x10, 0x71, 0x20, 0x69, 0x12, 0x67, 0x10, 0x75, 0x2B, 0x70, 0x54, 0x96, 0x27, 0x66,
    0x71, 0x20, 0x76, 0x12, 0x6D, 0x00, 0x79, 0x03, 0x6B, 0x00, 0x66, 0x70, 0x00, 0x00, 0x00, 0x07,
    0x71, 0x30, 0x6D, 0x11, 0x7B, 0x73, 0x00, 0x70, 0x00, 0x00, 0x00, 0x30, 0x71, 0x20, 0x68, 0x02,
    0x70, 0x00, 0x00, 0x00, 0x0A, 0x71, 0x20, 0x76, 0x02, 0x77, 0x09, 0x70, 0x00, 0x00, 0x00, 0x07,
    0x71, 0x20, 0x68, 0x02, 0x70, 0x00, 0x00, 0x00, 0x10, 0x71, 0x20, 0x69, 0x12, 0x67, 0x10, 0x75,
    0x2B, 0x6C, 0x10, 0x70, 0x02, 0x54, 0x26, 0x01, 0x71, 0x20, 0x76, 0x12, 0x6D, 0x00, 0x79, 0x03,
    0x6B, 0x00, 0x66, 0x70, 0x00, 0x00, 0x00, 0x07, 0x71, 0x30, 0x6D, 0x11, 0x7B, 0x73, 0x00, 0x70,
    0x00, 0x00, 0x00, 0x30, 0x71, 0x20, 0x68, 0x02, 0x70, 0x00, 0x00, 0x00, 0x0A, 0x71, 0x20, 0x76,
    0x02, 0x77, 0x09, 0x70, 0x00, 0x00, 0x00, 0x07, 0x71, 0x20, 0x68, 0x02, 0x70, 0x00, 0x00, 0x00,
    0x10, 0x71, 0x20, 0x69, 0x12, 0x67, 0x10, 0x75, 0x2B, 0x6B, 0x10, 0x70, 0x54, 0x77, 0x02, 0xE7,
    0x71, 0x20, 0x76, 0x12, 0x6D, 0x00, 0x79, 0x03, 0x6B, 0x00, 0x66, 0x70, 0x00, 0x00, 0x00, 0x07,
    0x71, 0x30, 0x6D, 0x11, 0x7B, 0x73, 0x00, 0x70, 0x00, 0x00, 0x00, 0x30, 0x71, 0x20, 0x68, 0x02,
    0x70, 0x00, 0x00, 0x00, 0x0A, 0x71, 0x20, 0x76, 0x02, 0x77, 0x09, 0x70, 0x00, 0x00, 0x00, 0x07,
    0x71, 0x20, 0x68, 0x02, 0x70, 0x00, 0x00, 0x00, 0x10, 0x71, 0x20, 0x69, 0x12, 0x67, 0x10, 0x75,
    0x2B, 0x70, 0x16, 0x36, 0xC2, 0xF6, 0x71, 0x20, 0x76, 0x12, 0x6D, 0x00, 0x79, 0x03, 0x6B, 0x00,
    0x66, 0x70, 0x00, 0x00, 0x00, 0x07, 0x71, 0x30, 0x6D, 0x11, 0x7B, 0x73, 0x00, 0x70, 0x00, 0x00,
    0x00, 0x30, 0x71, 0x20, 0x68, 0x02, 0x70, 0x00, 0x00, 0x00, 0x0A, 0x71, 0x20, 0x76, 0x02, 0x77,
    0x09, 0x70, 0x00, 0x00, 0x00, 0x07, 0x71, 0x20, 0x68, 0x02, 0x70, 0x00, 0x00, 0x00, 0x10, 0x71,
    0x20, 0x69, 0x12, 0x67, 0x10, 0x75, 0x2B, 0x70, 0x16, 0x86, 0x57, 0x47, 0x71, 0x20, 0x76, 0x12,
    0x6D, 0x00, 0x79, 0x02, 0x6B, 0x00
};

struct vm_instruction
{
    unsigned char opcode;
    char mnemonic[ 12 ];
};

vm_instruction g_instruction_set[] =
{
    { 0x00, "null" },
    { 0x01, "add" },
    { 0x02, "sub" },
    { 0x03, "mul" },
    { 0x04, "div" },
    { 0x05, "inc" },
    { 0x06, "dec" },
    { 0x07, "xor" },
    { 0x08, "and" },
    { 0x09, "push" },
    { 0x0A, "push" },
    { 0x0B, "pop" },
    { 0x0C, "mov" },
    { 0x0D, "movd" },
    { 0x0E, "mov2d" },
    { 0x0F, "loop" },
    { 0x10, "cmp" },
    { 0x11, "jl" },
    { 0x12, "jg" },
    { 0x13, "je" },
    { 0x14, "inc_ui" },
    { 0x15, "dec_ui" },
    { 0x16, "dxor" } 
};

std::string g_regNames[] =
{
    "r0",
    "r1",
    "r2",
    "r3",
    "cf"  // cmp flag
};

std::string resolve_src_rn( unsigned char ib ) {
    return g_regNames[ ( ib & 0xF ) ];
}

std::string resolve_dst_rn( unsigned char ib ) {
    return g_regNames[ ( ib >> 4 ) ];
}


std::string resolve_instruction( unsigned char** ipp, std::size_t *counter ) 
{
    unsigned char* ip = *ipp;
    std::size_t old_ip = ( std::size_t )ip;
    std::stringstream instr;
     
    *ip -= 0x66;

    switch ( *ip )
    {                    
    case 0x01: // add    
    case 0x02: // sub
    case 0x03: // mul
    case 0x04: // div                                                      
        instr << g_instruction_set[ *ip ].mnemonic << " ";
        instr << resolve_dst_rn( ip[ 1 ] ) << ", " << resolve_src_rn( ip[ 1 ] );
        instr << "\n";                         
        ( *ipp ) += 2;                                                              
        break;     
    case 0x05: // inc
    case 0x06: // dec     
    case 0x09: // push
        instr << g_instruction_set[ *ip ].mnemonic << " ";
        instr << resolve_dst_rn( ip[ 1 ] );
        instr << "\n";
        ( *ipp ) += 2;
        break;

    case 0x07: // xor
    case 0x08: // and   
        instr << g_instruction_set[ *ip ].mnemonic << " ";
        instr << resolve_dst_rn( ip[ 1 ] ) << ", " << resolve_src_rn( ip[ 1 ] );
        instr << "\n";
        ( *ipp ) += 2;
        break;
    case 0x0A: // push imm
    {
        unsigned int v = unsigned int( ( ip[ 1 ] << 24 ) + ( ip[ 2 ] << 16 ) + ( ip[ 3 ] << 8 ) + ip[ 4 ] );
        instr << g_instruction_set[ *ip ].mnemonic << " ";
        instr << std::hex << std::uppercase << v;
        instr << "\n";
        ( *ipp ) += 5;
        break;
    }
    case 0xB: // pop
        instr << g_instruction_set[ *ip ].mnemonic << " ";
        instr << resolve_dst_rn( ip[ 1 ] );
        instr << "\n";
        ( *ipp ) += 2;
        break;
    case 0x0C: // mov
        instr << g_instruction_set[ *ip ].mnemonic << " ";
        instr << resolve_dst_rn( ip[ 1 ] ) << ", " << resolve_src_rn( ip[ 1 ] );
        instr << "\n";
        ( *ipp ) += 2;
        break;     
    case 0x0D: // vm::vm_movUiToD
    case 0x0E: // vm::vm_movDToUi
        instr << g_instruction_set[ *ip ].mnemonic << " ";
        instr << resolve_dst_rn( ip[ 1 ] );
        instr << "\n";
        ( *ipp ) += 2;
        break;
    case 0x0F: // loop
        instr << g_instruction_set[ *ip ].mnemonic << " ";
        instr << std::hex << ( *counter - int( ip[1] ) ); // length       
        instr << std::endl;
        ( *ipp ) += 2;
        break;
    case 0x10: // cmp
        instr << g_instruction_set[ *ip ].mnemonic << " ";
        instr << resolve_dst_rn( ip[ 1 ] ) << ", " << resolve_src_rn( ip[ 1 ] );
        instr << "\n";
        ( *ipp ) += 2;
        break;
    case 0x11: // jl, jg, je
    case 0x12:
    case 0x13:
        instr << g_instruction_set[ *ip ].mnemonic << " ";       
        instr << std::hex << *counter + 2 + int( ip[ 1 ] ); // length   
        instr << std::endl;
        ( *ipp ) += 2;
        break;
    case 0x14:
    case 0x15:
        instr << g_instruction_set[ *ip ].mnemonic;
        instr << "\n";
        ( *ipp ) += 1;
        break;
    case 0x16:
        instr << g_instruction_set[ *ip ].mnemonic << " ";

        for ( int i = 1; i < 16; ++i )
        {
            instr << std::to_string( ( *ipp )[ i ] ) << ( i == 15 ? " " : ", " );
            ( *ipp )[ i ] ^= 0x66u;
        }

        instr << "; XOR'd -> ";

        for ( int i = 1; i < 16; ++i )
        {
            instr << std::to_string( ( *ipp )[ i ] ) << ( i == 15 ? " " : ", " );
            ( *ipp )[ i ] ^= 0x66u;
        }

        instr << "\n";
        ( *ipp ) += 16;
        break;    
    default:
        instr << "end\n";
        ( *ipp )++;            
        break;    
    }   

    *counter += ( std::size_t )( *ipp ) - old_ip;
    if ( *counter >= 0x204 )
        return "DEAD";

    return instr.str();
}

void resolve_code() 
{
    unsigned char* vm_code = &g_vm_bytecode[4];
    std::size_t last_address = 0;
    std::size_t address = 0;

    while ( true )
    {
        std::string instr = resolve_instruction( &vm_code, &address );                 
        if ( instr == "DEAD" )
            break;

        printf( "%04X | %s", last_address, instr.c_str() );
        last_address = address;
    }
}

int main()
{   
    resolve_code();
    return getchar();
}
